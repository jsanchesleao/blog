<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Roboto:ital,wght@0,400;0,700;1,400;1,700&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="css/style.css">
  <link rel="stylesheet" href="css/highlight.css">
  <title>Curry and compose</title>
</head>
<body>
  
<main>
  <article>
    <h1>Curry and compose</h1>
<h4>or why you should use something like Ramda in your code.</h4>
<p>When it comes to functional programming, the main cornerstone is composability, the ability to create new functions only by composing the existing ones. For example, we can use a function that returns true given a certain condition, and then reuse it in combination with a filter function, to select items in an array.</p>
<p>In javascript, though, this may lead to the creation of several functions that look like the following:</p>
<pre class="language-js"><code class="language-js"><span class="token keyword">var</span> <span class="token function-variable function">isGreaterThan</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">limit</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>  <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">value</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>    <span class="token keyword">return</span> value <span class="token operator">></span> limit<span class="token punctuation">;</span><br>  <span class="token punctuation">}</span><span class="token punctuation">;</span><br><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre>
<p>In that example, we have a function that creates another function. The first only binds a configuration value, the limit, and returns the second one, that in fact makes the comparison happen and return a boolean.</p>
<p>This function is in a curried form, that is, a function that always takes one single argument and returns a value, if it needs more arguments to compute the value, it returns another function to take the next argument, until all are passed, and then the final result is computed.</p>
<p>Using ES6’s arrow function syntax, this can be much less verbose:</p>
<pre class="language-js"><code class="language-js"><span class="token keyword">var</span> <span class="token function-variable function">isGreaterThan</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">limit</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">(</span><span class="token parameter">value</span><span class="token punctuation">)</span> <span class="token operator">=></span> value <span class="token operator">></span> limit<span class="token punctuation">;</span></code></pre>
<p>If not using ES6 yet, one excellent solution is to use a curry making function, like lodash’s _.curry, or ramda’s R.curry. What these functions do is take a multiple arguments function and return a curried version of it;</p>
<pre class="language-js"><code class="language-js"><span class="token comment">//Using ramda's curry</span><br><span class="token keyword">var</span> isGreaterThan <span class="token operator">=</span> <span class="token constant">R</span><span class="token punctuation">.</span><span class="token function">curry</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">limit<span class="token punctuation">,</span> value</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>    <span class="token keyword">return</span> value <span class="token operator">></span> limit<span class="token punctuation">;</span><br><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>Using <span class="token keyword">this</span> last form has the advantage that we can still pass two arguments to it<span class="token punctuation">,</span> and it will work<span class="token operator">:</span><br><br><span class="token function">greaterThan</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//true</span><br><span class="token function">greaterThan</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//true</span><br><span class="token keyword">var</span> greaterThanTen <span class="token operator">=</span> <span class="token function">greaterThan</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token function">greaterThanTen</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//true</span></code></pre>
<p>With curried forms, we have something like a factory of functions, we pass configuration data, receive a function to use in our compositions, and then we pass values to it. As the excellent talk by Brian Lonsdorf, <em>Hey Underscore, You’re Doing it Wrong</em>, we need to pass the data last, and the support values first.</p>
<p>Take for example the filter function. In lodash it takes the colletion as the first argument, and then a function to filter it as the second. They’re passing the data first, making it more difficult to compose with other functions, as we can see below:</p>
<pre class="language-js"><code class="language-js"><span class="token comment">//Using lodash here. </span><br><span class="token comment">//We flip the order of the arguments in the filter</span><br><span class="token comment">//function, passing the data last, and curry it.</span><br><span class="token keyword">var</span> filter <span class="token operator">=</span> _<span class="token punctuation">.</span><span class="token function">curry</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">fn<span class="token punctuation">,</span> collection</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>  <span class="token keyword">return</span> _<span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span>collection<span class="token punctuation">,</span> fn<span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
<p>Now we have a more composable filter function, and we can combine with greaterThan easy as a breeze.</p>
<pre class="language-js"><code class="language-js"><span class="token keyword">var</span> onlyPositives <span class="token operator">=</span> <span class="token function">filter</span><span class="token punctuation">(</span><span class="token function">greaterThan</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token function">onlyPositives</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// [4, 5]</span></code></pre>
<p>This is gold! And this is precisely what Ramda does with these base functions like map and filter. The final move is to take advantage of the fact they receive their data last and use a function to compose several functions. Underscore, lodash and ramda have it, and they’re all similar: you pass a lot of functions to it, and it returns a function that will pass the result of one function as arguments to the next, and return the result of the last, all right to left:</p>
<pre class="language-js"><code class="language-js"><span class="token comment">//read from bottom to top</span><br><br><span class="token comment">//+ getFirstPositivePlusOne :: [Number] => Number</span><br><span class="token keyword">var</span> getFirstPositivePlusOne <span class="token operator">=</span> <span class="token constant">R</span><span class="token punctuation">.</span><span class="token function">compose</span><span class="token punctuation">(</span><br>  <span class="token constant">R</span><span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                 <span class="token comment">// 4</span><br>  <span class="token constant">R</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                 <span class="token comment">// 3</span><br>  <span class="token function">filter</span><span class="token punctuation">(</span><span class="token function">greaterThan</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// [3, 6]</span><br><br>  <span class="token function">getFirstPositive</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 4</span></code></pre>
<p>Only by combining data-last curried functions with compose, we can write much more concise and reasonable code, and all with pure functions, and that is precisely what Ramda does, that underscore and lodash are doing wrong. It offers several pieces of behaviour, properly curried, so we can compose this way, which is called point free way. Point free code is code that does not declare “glue” variables, like this:</p>
<pre class="language-js"><code class="language-js"><span class="token comment">//lodash way</span><br><br><span class="token keyword">var</span> <span class="token function-variable function">onlyPositives</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">data</span><span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token comment">//glue variable (data)</span><br>  <span class="token keyword">return</span> data<span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">item</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment">//glue variable (item)</span><br>    <span class="token keyword">return</span> <span class="token function">greaterThan</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> item<span class="token punctuation">)</span><span class="token punctuation">;</span><br>  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br><span class="token punctuation">}</span> <br><br><span class="token comment">//pointfree ramda way</span><br><span class="token keyword">var</span> onlyPositivesPF <span class="token operator">=</span> <span class="token constant">R</span><span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span><span class="token function">greaterThan</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//no glue variables</span></code></pre>
<p>Even if your code would not be totally point free, by doing this you can remove a LARGE portion of boilerplate code and most of your unnecessary variables, thus producing smaller, more concise code, and also easier to identify flaws and bugs when they show up.</p>

  </article>
</main>

</body>
</html>
